# Code generated by scratch version v1.15.9. DO NOT EDIT.
# You can extend or override anything in ./Makefile

# Требования для работы scratch в окружениях Ozon.

# Подразумеваем, что все приложения используют go-модули.
export GO111MODULE=on

# Адрес кеширующего прокси для модулей.
export GOPROXY=https://goproxy.s.o3.ru

# Отключаем протокол sumdb.
export GOSUMDB=off

# Версия Go. Используется для проброса в LDFLAGS и проверках.
GO_MAJOR_VERSION := $(shell go version | cut -c 14- | cut -d' ' -f1 | cut -d'.' -f1)
GO_MINOR_VERSION := $(shell go version | cut -c 14- | cut -d' ' -f1 | cut -d'.' -f2)
GO_PATCH_VERSION := $(shell go version | cut -c 14- | cut -d' ' -f1 | cut -d'.' -f3)

# Полная версия Go, подставляемая в LDFLAGS (название историческое).
GO_VERSION_SHORT := $(GO_MAJOR_VERSION).$(GO_MINOR_VERSION).$(GO_PATCH_VERSION)

# Минимально поддерживаемая версия Go.
GO_MIN_SUPPORTED_MAJOR_VERSION := 1
GO_MIN_SUPPORTED_MINOR_VERSION := 19

# Некоторые платформенные библиотеки автоматически добавляют переменные в platform.yaml.
# Без запуска приложения выяснить используются ли такие библиотеки невозможно,
# поэтому для сборки конфига используется сборка исполняемого файла приложения
# и его запуск с параметром --generate-config-only. При этом приложение, распознав
# флаг, запишет в platform.yaml необходимую конфигурацию и завершится.
# Если вы точно уверены, что такие библиотеки не используются и вам не хочется
# в момент генерации конфига собирать исполняемый файл приложения - переопределите
# эту переменную в Makefile до включения в него файла scratch.mk.
USE_DYNAMIC_PLATFORM_CONFIG_RENDER ?= 1

# App version is sanitized CI branch name, if available.
# Otherwise git branch or commit hash is used.
APP_VERSION := $(if $(CI_COMMIT_REF_SLUG),$(CI_COMMIT_REF_SLUG),$(if $(GIT_BRANCH),$(GIT_BRANCH),$(GIT_HASH)))

# CI_PROJECT_ID is set in Gitlab CI, but we will fallback to app name if not present
CI_PROJECT_ID ?= newscratch

# Короткий хеш коммита.
GIT_HASH := $(shell git log --format="%h" --max-count 1 2> /dev/null)

# Последнее коммит-сообщение в логе, завернутое в base64 для передачи с помощью ldflags.
GIT_LOG := $(shell git log --decorate --oneline --max-count 1 2> /dev/null | base64 | tr -d '\n')

# Текущая ветка в git, в которой происходит сборка приложения.
GIT_BRANCH := $(shell git branch --show-current)

# Момент времени, в который было собрано приложение
BUILD_TS := $(shell date +%FT%T%z)

# Переменные, переопределяемые в приложении на этапе сборки.
# https://pkg.go.dev/cmd/go@go1.21.1#hdr-Compile_packages_and_dependencies
LDFLAGS = \
    -X 'gitlab.ozon.ru/platform/scratch/internal/app.Name=newscratch' \
    -X 'gitlab.ozon.ru/platform/scratch/internal/app.ProjectID=$(CI_PROJECT_ID)' \
    -X 'gitlab.ozon.ru/platform/scratch/internal/app.Version=$(APP_VERSION)' \
    -X 'gitlab.ozon.ru/platform/scratch/internal/app.GoVersion=$(GO_VERSION_SHORT)' \
    -X 'gitlab.ozon.ru/platform/scratch/internal/app.BuildDate=$(BUILD_TS)' \
    -X 'gitlab.ozon.ru/platform/scratch/internal/app.GitLog=$(GIT_LOG)' \
    -X 'gitlab.ozon.ru/platform/scratch/internal/app.GitHash=$(GIT_HASH)' \
    -X 'gitlab.ozon.ru/platform/scratch/internal/app.GitBranch=$(GIT_BRANCH)' \
    -X 'gitlab.ozon.ru/platform/scratch/internal/app.ScratchVersion=v1.15.9' \
    -X 'gitlab.ozon.ru/platform/scratch/internal/app.publicPortDefault=' \
    -X 'gitlab.ozon.ru/platform/scratch/internal/app.adminPortDefault=' \
    -X 'gitlab.ozon.ru/platform/scratch/internal/app.grpcPortDefault=' \
    -X 'gitlab.ozon.ru/platform/scratch/internal/app.channelzPortDefault='

# Дополнительные параметры для сборки приложения.
# Если необходимо дополнить, можно переопределить
# в файле Makefile.
BUILD_ENVPARMS ?= CGO_ENABLED=0

# Файл конфигурации Mimir - инструмента верндоринга
# и сборки кода на основе proto-файлов.
# Переопределять не рекомендуется.
MIMIR_CFG = "mimir.yaml"

# Директория, в которой хранятся исполняемые
# файлы проекта и зависимости, необходимые для сборки.
LOCAL_BIN := $(CURDIR)/bin

# Шорткат для исполняемого файла Scratch.
SCRATCH_BIN := $(LOCAL_BIN)/scratch

# Шорткат для исполняемого файла Mimir.
MIMIR_BIN := $(LOCAL_BIN)/mimir-cli

# Дополнительные аргументы, передаваемые Mimir при вызове.
# Переопределить можно в файле Makefile.
MIMIR_GEN_ARGS ?=

# Тег Buf, который необходим Mimir для сборки кода из proto-файлов.
BUF_TAG := v1.4.0

# Шорткат для исполняемого файла Buf.
BUF_BIN := $(LOCAL_BIN)/buf

# Шорткат для исполняемого файла goimports.
GOIMPORTS_BIN := $(LOCAL_BIN)/goimports



all: test build ## Команда по умолчанию: запуск тестов и сборка приложения

help: ## Вывести справку по доступным командам
	@$(SCRATCH_BIN) render-makefile-help

.get-scratch:
	$(info Downloading scratch source code)
	@[ -f go.mod ] || go mod init gitlab.ozon.ru/newscratch
	go get gitlab.ozon.ru/platform/scratch@v1.15.9

get-scratch: .get-scratch ## Скачать последнюю версию Scratch и проинициализировать go.mod, если модуля еще нет

install-scratch: export GOBIN := $(LOCAL_BIN)
install-scratch: ## Установить Scratch в текущую директорию с исполняемыми файлами
	@# Проверяем, установлен ли Scratch в директорию с локальными исполняемыми файлами.
	$(eval local_scratch_bin=$(shell command -v $(SCRATCH_BIN) 2> /dev/null))
	@# Выясняем версию Scratch, установленного в директории с локальными исполняемыми файлами.
	$(eval local_scratch_bin_version=$(shell $(SCRATCH_BIN) version 2> /dev/null))

	@# Проверяем, установлен ли Scratch глобально.
	$(eval global_scratch_bin=$(shell command -v scratch 2> /dev/null))
	@# Выясняем версию глобально установленного Scratch.
	$(eval global_scratch_bin_version=$(shell scratch version 2> /dev/null))

	@# Далее выполняем следующие шаги:
	@#    1. Если Scratch установлен глобально и его версия совпадает с v1.15.9,
	@#       копируем глобально установленный исполняемый файл.
	@#    2. В противном случае Scratch устанавливается напрямую из исходников.
	@if ! [ $(local_scratch_bin) ] || \
		! [ "$(local_scratch_bin_version)" = "scratch version: v1.15.9" ]; then \
		echo "Installing scratch executable"; \
		if [ $(global_scratch_bin) ] && \
			[ "$(global_scratch_bin_version)" = "scratch version: v1.15.9" ]; then \
			echo "Copying globally installed Scratch to $(LOCAL_BIN)"; \
			mkdir -p $(LOCAL_BIN) && \
			rm -rf $(SCRATCH_BIN) && \
			cp $(shell command -v scratch 2> /dev/null) $(SCRATCH_BIN); \
			echo "Scratch has been installed to $(LOCAL_BIN)"; \
		else \
			echo "Installing Scratch from sources to $(LOCAL_BIN)..."; \
			go install gitlab.ozon.ru/platform/scratch/cmd/scratch@v1.15.9; \
			echo "Scratch has been installed to $(LOCAL_BIN)"; \
		fi \
	else \
		echo "Scratch executable is already installed"; \
	fi


# Шорткат для golangci-lint
GOLANGCI_BIN := $(LOCAL_BIN)/golangci-lint

# Требуемая актуальная версия линтера.
GOLANGCI_TAG ?= 1.54.2

# Поиск локальной версии golangci-lint.
ifneq ($(shell command -v $(GOLANGCI_BIN)),)
# Найден локально установленный golangci-lint.
GOLANGCI_BIN_VERSION := $(shell $(GOLANGCI_BIN) --version 2> /dev/null)

# Парсинг версии локально установленного golangci-lint.
ifneq ($(GOLANGCI_BIN_VERSION),)
GOLANGCI_BIN_VERSION_SHORT := $(shell echo "$(GOLANGCI_BIN_VERSION)" | sed -En 's/.*([0-9]+\.[0-9]+\.[0-9]+) built.*/\1/p' | sed -E 's/v(.*)/\1/g') # golangci-lint, в зависимости от версии, может отдавать версию как с 'v' так и без
else
# Не получилось узнать версию локально установленного golangci-lint.
GOLANGCI_BIN_VERSION_SHORT := 0
endif

# Сортируем версии. Если версия локально установленного golangci-lint
# совпадает с требуемой - используем локальную версию.
ifneq ("$(GOLANGCI_TAG)", "$(word 1, $(sort $(GOLANGCI_TAG) $(GOLANGCI_BIN_VERSION_SHORT)))")
GOLANGCI_BIN :=
endif

endif

# Проверка глобального golangci-lint.
ifneq ($(shell command -v golangci-lint 2> /dev/null),)
# Найден глобально установленный golangci-lint.
GOLANGCI_VERSION := $(shell golangci-lint --version 2> /dev/null)

# Парсинг версии глобально установленного golangci-lint.
ifneq ($(GOLANGCI_VERSION),)
GOLANGCI_VERSION_SHORT := $(shell echo "$(GOLANGCI_VERSION)" | sed -En 's/.*([0-9]+\.[0-9]+\.[0-9]+) built.*/\1/p' | sed -E 's/v(.*)/\1/g') # golangci-lint, в зависимости от версии, может отдавать версию как с 'v' так и без
else
# Не получилось узнать версию глобально установленного golangci-lint.
GOLANGCI_VERSION_SHORT := 0
endif

# Сортируем версии. Если версия глобально установленного golangci-lint
# совпадает с требуемой - используем глобальную версию.
# В противном случае будет произведена установка golangci-lint
# из исходников в локальную директорию с исполняемыми файлами.
ifeq ("$(GOLANGCI_TAG)", "$(word 1, $(sort $(GOLANGCI_TAG) $(GOLANGCI_VERSION_SHORT)))")
GOLANGCI_BIN := $(shell command -v golangci-lint 2> /dev/null)
endif

endif

install-lint: export GOBIN := $(LOCAL_BIN)
install-lint: ## Установить golangci-lint в текущую директорию с исполняемыми файлами
ifeq ($(wildcard $(GOLANGCI_BIN)),)
	@# Если в предыдущих шагах не был найден исполняемый
	@# файл линтера - устанавливаем его из исходников локально.
	$(info Installing golangci-lint v$(GOLANGCI_TAG))
	go install github.com/golangci/golangci-lint/cmd/golangci-lint@v$(GOLANGCI_TAG)
# Устанавливаем текущий путь для исполняемого файла линтера.
GOLANGCI_BIN := $(LOCAL_BIN)/golangci-lint
else
	$(info Golangci-lint is already installed to $(GOLANGCI_BIN))
endif

.lint: install-lint
	$(info Running lint against changed files...)
	$(GOLANGCI_BIN) run \
		--new-from-rev=origin/master \
		--config=.golangci.pipeline.yaml \
		./...

lint: .lint ## Запуск golangci-lint на изменениях, отличающихся от мастера

.lint-full: install-lint
	$(info Running lint against all project files...)
	$(GOLANGCI_BIN) run \
		--config=.golangci.pipeline.yaml \
		./...

lint-full: .lint-full ## Запуск golangci-lint по всем файлам проекта

.bin-deps: export GOBIN := $(LOCAL_BIN)
.bin-deps:
	$(info Installing binary dependencies...)
	
	go install gitlab.ozon.ru/platform/mimir-cli/cmd/mimir-cli@scratch-15-rc
	go install gitlab.ozon.ru/platform/scratch/cmd/protoc-gen-scratch@v0.5.0
	go install gitlab.ozon.ru/platform/scratch/cmd/protoc-gen-hedgereqs@v0.2.0
	go install github.com/grpc-ecosystem/grpc-gateway/v2/protoc-gen-grpc-gateway@v2.16.0
	go install github.com/grpc-ecosystem/grpc-gateway/v2/protoc-gen-openapiv2@v2.16.0
	go install google.golang.org/protobuf/cmd/protoc-gen-go@v1.28.1
	go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@v1.2.0
	go install gitlab.ozon.ru/platform/esc@v0.2.1
	go install github.com/planetscale/vtprotobuf/cmd/protoc-gen-go-vtproto@v0.3.0
	go install github.com/mitchellh/gox@v1.0.1
	go install github.com/shenwei356/rush@v0.5.3
	go install golang.org/x/tools/cmd/goimports@v0.1.9
	go install github.com/bufbuild/buf/cmd/buf@$(BUF_TAG)
	go install gitlab.ozon.ru/platform/go/protoc-gen-kafka/cmd/protoc-gen-go-o3-kafka@v1.0.0

bin-deps: .bin-deps install-scratch ## Установить зависимости, необходимые для генерации кода

.deps:
	$(info Installing dependencies...)
	go mod download

deps: .deps ## Установить зависимости (go mod download)

.pgen-init:
# Создаем mimir.yaml если не найден.
ifeq ($(wildcard mimir.yaml),)
	go mod tidy

	$(MIMIR_BIN) \
		--config mimir.yaml \
		mod init \
		--project gitlab.ozon.ru/newscratch --paths api/**
endif

.deps-pb: .pgen-init
	$(info Vendoring proto dependencies...)
	rm -rf ./vendor.protogen
	$(MIMIR_BIN) vendor --config $(MIMIR_CFG)

deps-pb: .deps-pb ## Запустить вендоринг proto-зависимостей с помощью Mimir

# Если вам недостаточно такого вызова, переопределите данную команду в Makefile
# проекта.
# Следует обратить внимание, что в CI тесты запускаются без помощи Makefile.
# https://gitlab.ozon.ru/pub/ci/-/blob/0.0.5/templates/go/.go.gitlab-ci.yml (джоба .test)
#
# Пример:
#
# include scratch.mk
#
#.test:
#	$(info Running tests...)
#	go test -v -race ./...
#
.test:
	$(info Running tests...)
	go test ./...

test: .test ## Запустить юнит-тесты

# CMD_LIST список таргетов (через пробел) которые надо собрать
# можно переопределить в Makefile, по дефолту все из ./cmd кроме основного пакета
# пример переопределения CMD_LIST:= ./cmd/example ./cmd/app ./cmd/cron
ifndef CMD_LIST
CMD_LIST := $(shell ls ./cmd | sed -e 's/^/.\/cmd\//' | grep -v "./cmd/newscratch")
endif

# Определение текущий ос.
ifndef HOSTOS
HOSTOS := $(shell go env GOHOSTOS)
endif

# Определение текущий архитектуры.
ifndef HOSTARCH
HOSTARCH := $(shell go env GOHOSTARCH)
endif

ifndef BIN_DIR
BIN_DIR = $(LOCAL_BIN)
endif

# Шорткат для gox, использующегося
# для параллельной сборки приложений.
GOX_BIN := $(LOCAL_BIN)/gox

# Проверка наличия локального gox.
ifeq ($(wildcard $(GOX_BIN)),)
GOX_BIN :=
endif

# Проверка наличия gox, установленного глобально.
ifneq (, $(shell which gox))
GOX_BIN := $(shell which gox)
endif

# Шорткат для rush, использующегося
# для параллельной сборки приложений.
RUSH_BIN := $(LOCAL_BIN)/rush

# Проверка наличия локального rush.
ifeq ($(wildcard $(RUSH_BIN)),)
RUSH_BIN :=
endif

# Проверка наличия rush, установленного глобально.
ifneq (, $(shell which rush))
RUSH_BIN := $(shell which rush)
endif

# Если необходимо собрать только основной сервис,
# можно указать в Makefile DISABLE_CMD_LIST_BUILD = 1
DISABLE_CMD_LIST_BUILD ?= 0

# Переменная со списком бинарников для сборки,
# по умолчанию только основной бинарник сервиса,
# если не выключена сборка Cron-бинарников через
# DISABLE_CMD_LIST_BUILD=1, то они также будут
# добавлены в список.
BUILD_PATHS ?= ./cmd/newscratch
ifeq (0, $(DISABLE_CMD_LIST_BUILD))
ifneq (, $(CMD_LIST))
BUILD_PATHS += $(CMD_LIST)
endif
endif

# Указывает путь до профиля для Profile-Guided Optimization.
# По умолчанию ищет в текущей директории файл default.pgo.
PGO_PROFILE_FILENAME ?= default.pgo
PGO_PROFILE_PATH = $(wildcard $(CURDIR)/$(PGO_PROFILE_FILENAME))
ifneq (, $(PGO_PROFILE_PATH))
PGO_FLAG = -pgo=$(PGO_PROFILE_PATH)
LDFLAGS += -X 'gitlab.ozon.ru/platform/scratch/internal/app/telemetry/features/pgo.enabled=true'
endif

.build: .validate-min-go-version install-scratch
	$(info Запускаем сборку основного приложения...)

ifneq (, $(PGO_FLAG))
	$(call _validate_go_version_func,1,20)
endif

	@# Проверяем совпадение версий scratch в go.mod и scratch.mk.
	$(SCRATCH_BIN) check-scratch-version

	@# Берем итоговый список из BUILD_PATHS, перенаправляем через пайп в Rush
	@# --keep-order
	@#  cохраняет порядок строк для каждого потока
	@# --record-delimiter=" "
	@#  разделяем инпут из пайпа по пробелам
	@# --trim=b
	@#  для каждого инпута из пайпа обрезаем пробелы и \n с обоих сторон

	@echo $(BUILD_PATHS) | $(RUSH_BIN) \
		--keep-order \
		--record-delimiter=" " \
		--trim=b \
		'$(BUILD_ENVPARMS) go build -o="$(BIN_DIR)/{%}" -ldflags "$(LDFLAGS)" $(PGO_FLAG) {}'

build: .build ## Запустить сборку приложения

# Включает/выключает поддержку сборки приложения
# со встроенной возможностью сбора e2e покрытия.
ENABLE_COLLECTING_INTEGRATION_TESTS ?= no

build-cover: .build-cover ## Запустить сборку приложения с поддержкой тестового покрытя (Go >= 1.20)

.build-cover:
ifeq ("$(ENABLE_COLLECTING_INTEGRATION_TESTS)", "yes")
	$(call _validate_go_version_func,1,20)
	$(info Запускаем сборку основного приложения с поддержкой сбора e2e тестового покрытия...)

	$(BUILD_ENVPARMS) \
	go build \
		-cover \
		-covermode=atomic \
		-ldflags "$(LDFLAGS)" \
		-o "$(BIN_DIR)/newscratch-cover" \
		$(PGO_FLAG) \
		./cmd/newscratch
endif

.run: .validate-min-go-version
	$(info Запуск приложения...)

ifneq (, $(PGO_FLAG))
	$(call _validate_go_version_func,1,20)
endif

	$(BUILD_ENVPARMS) \

	@# --local-config-enabled заставляет приложение
	@#   читать конфигурацию из файла ./o3/k8s/values_local.yaml.

	@# --bind-localhost заставляет приложение запускаться
	@#   на 127.0.0.1 вместо 0.0.0.0. В macOS этот флаг позволяет
	@#   избежать окна с подтверждением разрешения на прослушивания
	@#   трафика на всех интерфейсах.

	go run \
		-ldflags "$(LDFLAGS)" \
		$(PGO_FLAG) \
		./cmd/newscratch \
		--local-config-enabled \
		--bind-localhost

run: .run ## Запустить приложение локально в режиме разработки

generate-config: .validate-min-go-version install-scratch ## Сгенерировать конфигурацию приложения
	$(SCRATCH_BIN) generate config -v
	go mod tidy
ifeq ($(USE_DYNAMIC_PLATFORM_CONFIG_RENDER),1)
	@# Генерируем конфигурацию для основного приложения
	$(info Generating main app configuration...)
	VAULT_ADDR="" \
	$(BUILD_ENVPARMS) \
	go run \
		-ldflags "$(LDFLAGS)" \
		./cmd/newscratch \
		--generate-config-only \
		--local-config-enabled

	@# Генерируем конфигурацию для остальных приложений.
	$(info Generating configuration for other binaries...)
	for binary in $(CMD_LIST); do \
		VAULT_ADDR="" \
		$(BUILD_ENVPARMS) \
		go run \
			-ldflags "$(LDFLAGS)" \
			$$binary \
			--generate-config-only \
			--local-config-enabled; \
	done;
	$(RM) $(TMPDIR)/.platform.prev.yaml
endif

.generate:
	@[ -f "buf.gen.yaml" ] || (echo "ERROR: buf.gen.yaml not found. Run 'scratch update --confirm' to fix." &&  exit 1)

	$(info Generating code...)

	@# С помощью Mimir запускаем генерацию кода на основе proto-файлов.
	$(info Generating code based on .proto files...)
	$(MIMIR_BIN) generate \
		$(MIMIR_GEN_ARGS) \
		--config $(MIMIR_CFG) \
		--buf-bin $(BUF_BIN)

	@# Удаляем *.pb.scratch.go во избежание поломки кода
	@# на этапе генерации, связанной с переездом с esc на embed.
	$(info Removing *.pb.scratch.go files...)
	find $(CURDIR) \
		-type f \
		-name "*.pb.scratch.go" \
		-exec dirname {} \; | \
		PATH="$(LOCAL_BIN):$(PATH)" \
		xargs -I {} bash -c 'cd {} && go mod tidy && go generate -run "(scratch|esc)" ./...'

	$(info Tidying module requirements...)
	go mod tidy

	$(info Running goimports...)
	$(GOIMPORTS_BIN) -w ./

generate: .validate-min-go-version bin-deps deps-pb .generate generate-config ## Запустить генерацию кода из proto-файлов

fast-generate: deps-pb .generate ## Запустить генерацию кода из proto-файлов с пропуском шага генерации конфига и установки бинарных зависимостей

# Образ линтера, использующийся в CI.
# При необходимости указания других версий образа в Makefile необходимо переопределить данную переменную
# Предполагается, что за свежестью образов линтера пользователь следит самостоятельно.
GOLANGCI_LINTER_IMAGE ?= "gitlab-registry.ozon.ru/platform/lint/$(strip $(GOLANGCI_TAG))/platform:v0.10"

ci-lint: ## Запустить линтер из CI локально внутри образа Docker
	$(info Running CI lint)
	@# Запускаем платформенный линтер в контейнере. Здесь используется
	@# линтер из репозитория gitlab.ozon.ru/platform/lint. Помимо golangci-lint
	@# запускаются еще modguard, goban и paralleltest.
	@# * Modguard проверяет соответствуют ли зависимости приложения тем, что
	@#     определены в файле https://gitlab.ozon.ru/platform/lib-template-go/-/blob/master/.gauze.yaml.
	@# * Goban проверяет наличие в приложении запрещенных вызовов из файла
	@#     https://gitlab.ozon.ru/platform/lib-template-go/-/blob/master/goban.yaml.
	@# * Paralleltest проверяет наличие вызова t.Parallel() в тестах.
	@docker run \
		--rm  \
		--volume $(CURDIR):/code \
		--volume $(shell go env GOCACHE):/root/.cache/go-build \
		--volume $(shell go env GOMODCACHE):/root/.go/pkg/mod \
		--env CI_COMMIT_REF_NAME=release \
		--user $(shell id -u):$(shell id -g) \
		--workdir /code $(GOLANGCI_LINTER_IMAGE) \
		lint || exit $?

define _validate_go_version_func
	$(eval _GO_MAJOR_VERSION=$(shell go version | cut -c 14- | cut -d' ' -f1 | cut -d'.' -f1))
	$(eval _GO_MINOR_VERSION=$(shell go version | cut -c 14- | cut -d' ' -f1 | cut -d'.' -f2))
	$(eval _GO_MIN_SUPPORTED_MAJOR_VERSION = $(1))
	$(eval _GO_MIN_SUPPORTED_MINOR_VERSION = $(2))
	$(eval _GO_VERSION_VALIDATION_ERR_MSG=Golang \
		version is not supported, please update to at least \
		${_GO_MIN_SUPPORTED_MAJOR_VERSION}.${_GO_MIN_SUPPORTED_MINOR_VERSION})

	@if [ ${_GO_MAJOR_VERSION} -lt ${_GO_MIN_SUPPORTED_MAJOR_VERSION} ]; then \
		echo '${_GO_VERSION_VALIDATION_ERR_MSG}';\
		exit 1; \
	elif [ ${_GO_MINOR_VERSION} -lt ${_GO_MIN_SUPPORTED_MINOR_VERSION} ] ; then \
		echo '${_GO_VERSION_VALIDATION_ERR_MSG}';\
		exit 1; \
	fi
endef

# Валидация минимально поддерживаемой версии Go.
.validate-min-go-version:
	$(call _validate_go_version_func,\
		$(GO_MIN_SUPPORTED_MAJOR_VERSION),\
		$(GO_MIN_SUPPORTED_MINOR_VERSION))

# Объявляем, что текущие команды не являются файлами и
# инструктируем Makefile не искать изменений в файловой системе.
.PHONY: \
	all \
	test \
	build \
	help \
	.get-scratch \
	get-scratch \
	.install-scratch \
	install-scratch \
	.install-lint \
	install-lint \
	.lint \
	.validate-min-go-version \
	lint \
	.lint-full \
	lint-full \
	.deps \
	deps \
	.bin-deps \
	bin-deps \
	.pgen-init \
	.deps-pb \
	deps-pb \
	.test \
	test \
	.build \
	build \
	.build-cover \
	build-cover \
	.run \
	run \
	.generate \
	generate \
	generate-config \
	fast-generate \
	ci-lint
